{
  "hash": "991daf47405be33249f6f3898a9182ad",
  "result": {
    "engine": "knitr",
    "markdown": "# Manuten√ß√£o Preditiva com Dados Sensor\n\n## Introdu√ß√£o\n\nUso de dados de sensores e machine learning para predi√ß√£o de falhas.\n\n## Prepara√ß√£o de Dados de Sensores\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(lubridate)\n\n# Carregar dados de sensores\nsensores <- read_csv(\"resources/data/sensores_compressor.csv\")\n\n# Pr√©-processamento\nsensores_clean <- sensores %>%\n  mutate(\n    timestamp = ymd_hms(timestamp),\n    temp_norm = (temperatura - mean(temperatura)) / sd(temperatura),\n    vibr_norm = (vibracao - mean(vibracao)) / sd(vibracao)\n  ) %>%\n  arrange(equipamento_id, timestamp)\n\nhead(sensores_clean)\n```\n:::\n\n\n\n\n\n\n\n\n## Feature Engineering\n\n### Estat√≠sticas em Janela Deslizante\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(zoo)\n\n# Criar features\nsensores_features <- sensores_clean %>%\n  group_by(equipamento_id) %>%\n  arrange(timestamp) %>%\n  mutate(\n    temp_mean_7d = rollmean(temperatura, k = 7*24, fill = NA, align = \"right\"),\n    temp_max_7d = rollmax(temperatura, k = 7*24, fill = NA, align = \"right\"),\n    temp_std_7d = rollapply(temperatura, width = 7*24, FUN = sd,\n                            fill = NA, align = \"right\"),\n    vibr_trend = c(NA, diff(vibracao))\n  ) %>%\n  ungroup()\n```\n:::\n\n\n\n\n\n\n\n\n## Detec√ß√£o de Anomalias\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(anomalize)\n\n# Decomposi√ß√£o e detec√ß√£o\nanomalias <- sensores_clean %>%\n  time_decompose(temperatura, method = \"stl\") %>%\n  anomalize(remainder, method = \"iqr\") %>%\n  time_recompose()\n\n# Visualizar\nanomalias %>%\n  plot_anomalies(time_recomposed = TRUE) +\n  labs(title = \"Detec√ß√£o de Anomalias - Temperatura\")\n```\n:::\n\n\n\n\n\n\n\n\n## Modelo Preditivo com Machine Learning\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(caret)\nlibrary(randomForest)\n\n# Preparar dataset\n# Assumir que temos features + label 'falha_proxima'\ndados_treino <- sensores_features %>%\n  filter(!is.na(temp_mean_7d)) %>%\n  select(temp_mean_7d, temp_std_7d, vibr_trend, falha_proxima)\n\n# Dividir treino/teste\nset.seed(123)\nindices_treino <- createDataPartition(dados_treino$falha_proxima,\n                                      p = 0.7, list = FALSE)\ntreino <- dados_treino[indices_treino, ]\nteste <- dados_treino[-indices_treino, ]\n\n# Treinar Random Forest\nmodelo_rf <- randomForest(falha_proxima ~ .,\n                          data = treino,\n                          ntree = 100,\n                          importance = TRUE)\n\n# Predi√ß√£o\npred_teste <- predict(modelo_rf, teste)\n\n# Matriz de confus√£o\nconfusionMatrix(pred_teste, teste$falha_proxima)\n```\n:::\n\n\n\n\n\n\n\n\n## Import√¢ncia de Features\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Plot import√¢ncia\nvarImpPlot(modelo_rf, main = \"Import√¢ncia das Vari√°veis\")\n```\n:::\n\n\n\n\n\n\n\n\n## S√©ries Temporais com Prophet\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(prophet)\n\n# Preparar dados\ndf_prophet <- sensores_clean %>%\n  select(ds = timestamp, y = temperatura)\n\n# Ajustar modelo\nm <- prophet(df_prophet, changepoint.prior.scale = 0.05)\n\n# Previs√£o 30 dias\nfuture <- make_future_dataframe(m, periods = 30, freq = \"day\")\nforecast <- predict(m, future)\n\n# Visualizar\nplot(m, forecast)\nprophet_plot_components(m, forecast)\n```\n:::\n\n\n\n\n\n\n\n\n## Threshold Din√¢mico\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Calcular threshold baseado em percentil hist√≥rico\nthreshold_dinamico <- sensores_clean %>%\n  group_by(equipamento_id) %>%\n  summarize(\n    temp_p95 = quantile(temperatura, 0.95),\n    vibr_p95 = quantile(vibracao, 0.95)\n  )\n\n# Aplicar alertas\nalertas <- sensores_clean %>%\n  left_join(threshold_dinamico, by = \"equipamento_id\") %>%\n  filter(temperatura > temp_p95 | vibracao > vibr_p95)\n```\n:::\n\n\n\n\n\n\n\n\n## Exerc√≠cios\n\nüìù **Exerc√≠cio 1**: Implemente detec√ß√£o de anomalias com IQR.\n\nüìù **Exerc√≠cio 2**: Treine modelo XGBoost e compare com Random Forest.\n\nüìù **Exerc√≠cio 3**: Crie dashboard Shiny para monitoramento em tempo real.\n\n## Resumo\n\nüîî **Pontos-chave:**\n\n- Feature engineering √© crucial\n- Detec√ß√£o de anomalias identifica comportamento anormal\n- Machine learning prev√™ falhas antes da ocorr√™ncia\n- Manuten√ß√£o preditiva reduz custos e downtime\n\n---\n\n**Pr√≥ximo cap√≠tulo:** Modelos de Confiabilidade de Sistema\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {
      "knitr": [
        "{\"type\":\"list\",\"attributes\":{},\"value\":[]}"
      ]
    },
    "preserve": null,
    "postProcess": false
  }
}